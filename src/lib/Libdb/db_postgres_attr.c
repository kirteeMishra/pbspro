/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */


/**
 * @file    db_postgres_attr.c
 *
 * @brief
 *	Implementation of the attribute related functions for postgres
 *
 */

#include <pbs_config.h>   /* the master config generated by configure */
#include "pbs_db.h"
#include "db_postgres.h"

/*
 * initially allocate some space to buffer, anything more will be
 * allocated later as required. Just allocate 1000 chars, hoping that
 * most common sql's might fit within it without needing to resize
 */
#define INIT_BUF_SIZE 1000

/**
 * @brief
 *	Load the attribute values from the resultset into the attribute object
 *  passed
 *
 * @param[in]	res - Postgres resultset obtained by executing a query
 * @param[out]	pattr - Attribute object that is populated with values from DB
 * @param[in]	row - The current row of the resultset that is to be used
 *
 *
 */
static void
load_attr(PGresult *res, pbs_db_attr_info_t *pattr, int row)
{
	strcpy(pattr->attr_name, PQgetvalue(res, row,
		PQfnumber(res, "attr_name"))); /* name */
	pattr->attr_resc = PQgetvalue(res, row,
		PQfnumber(res, "attr_resource")); /* resource */
	pattr->attr_value = PQgetvalue(res, row,
		PQfnumber(res, "attr_value")); /* value */
	pattr->attr_flags = strtol(PQgetvalue(res, row,
		PQfnumber(res, "attr_flags")), NULL, 10); /* flags */
}

/**
 * @brief
 *	Start a statement to insert multiple attributes in one DB call
 *
 * @param[in]	  conn - Database connection handle
 * @param[in]	  info - The database object to be inserted
 * @param[in/out] sql  - The buffer to use for creating the insert query
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 *
 *
 */
int
pbs_db_insert_multiattr_start(pbs_db_conn_t *conn,
	pbs_db_obj_info_t *info,
	pbs_db_sql_buffer_t *sql)
{
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;


	if (resize_buff(sql, INIT_BUF_SIZE) != 0)
		return -1;

	strcpy(sql->buff, "insert into ");

	if (pattr->parent_obj_type == PARENT_TYPE_JOB)
		strcat(sql->buff, "pbs.job_attr");
	else if (pattr->parent_obj_type == PARENT_TYPE_SERVER)
		strcat(sql->buff, "pbs.server_attr");
	else if (pattr->parent_obj_type == PARENT_TYPE_QUE_ALL)
		strcat(sql->buff, "pbs.queue_attr");
	else if (pattr->parent_obj_type == PARENT_TYPE_RESV)
		strcat(sql->buff, "pbs.resv_attr");
	else if (pattr->parent_obj_type == PARENT_TYPE_NODE)
		strcat(sql->buff, "pbs.node_attr");
	else if (pattr->parent_obj_type == PARENT_TYPE_SCHED)
		strcat(sql->buff, "pbs.scheduler_attr");
	strcat(sql->buff, " values");

	return 0;
}

/**
 * @brief
 *	Add an attribute to the multi-attribute insert statment created eariler
 *
 * @param[in]	  conn - Database connection handle
 * @param[in]	  firsttime - Is it being called for the firsttime?
 * @param[in]	  info - The database object to be inserted
 * @param[in/out] sql  - The buffer to used to hold the final sql query that
 *			is being formed by calling this function multiple times.
 *
 * @param[in]	part - This buffer is used for hold the a "part" of the whole
 *			sql query. This is eventually added to the sql buffer.
 *			Thus, part is a "work" buffer, and "sql" hold the final
 *			sql formed, that would be executed at the end.
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 *
 */
int
pbs_db_insert_multiattr_add(pbs_db_conn_t *conn, pbs_db_obj_info_t *info,
	int firsttime, pbs_db_sql_buffer_t *sql,
	pbs_db_sql_buffer_t *part)
{
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;
	static char fmt[] = "%c ('%s', '%s', '%s', '%s', %d)";
	char *val_escaped;

	int size = sizeof(fmt) + 1;
	int attr_str_len = 0;

	val_escaped = pbs_db_escape_str(conn, pattr->attr_value);
	if (!val_escaped)
		return -1;

	/*
	 * +5 is for the flags, its integer and the size depends of the number
	 * of digits after coversion to string, which we dont know yet, so
	 * using a max of 5 digits
	 */
	attr_str_len = strlen(pattr->parent_id) + strlen(pattr->attr_name) +
		strlen(pattr->attr_resc) + strlen(val_escaped) + 5;
	size += attr_str_len;

	if (resize_buff(part, attr_str_len) != 0) {
		free(val_escaped);
		return -1;
	}
	if (resize_buff(sql, size) != 0) {
		free(val_escaped);
		return -1;
	}

	part->buff[0]=0;
	sprintf(part->buff, fmt,
		(firsttime == 0)? ',':' ',
		pattr->parent_id,
		pattr->attr_name,
		pattr->attr_resc,
		val_escaped,
		pattr->attr_flags);

	free(val_escaped); /* done with val_escaped */

	strcat(sql->buff, part->buff);
	return 0;
}

/**
 * @brief
 *	Execute the multi-attr insert sql query that is created so far
 *
 * @param[in]	conn - Database connection handle
 * @param[in]	info - The database object to be inserted
 * @param[in]	sql  - The buffer to use for creating the insert query
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 *
 */
int
pbs_db_insert_multiattr_execute(pbs_db_conn_t *conn,
	pbs_db_obj_info_t *info,
	pbs_db_sql_buffer_t *sql)
{
	int rc;

	if (resize_buff(sql, 1) != 0) {
		return -1;
	}
	strcat(sql->buff, ";");
	rc = pbs_db_execute_str(conn, sql->buff);
	if (rc != 0)
		return -1;
	return 0;
}

/**
 * @brief
 *	Insert an attribute to the database
 *
 * @param[in]	conn - Database connection handle
 * @param[in]	info - The database object to be inserted
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 *
 */
int
pg_db_insert_attr(pbs_db_conn_t *conn, pbs_db_obj_info_t *info)
{
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;

	if (pattr->parent_obj_type == PARENT_TYPE_JOB)
		strcpy(conn->conn_sql, STMT_INSERT_JOBATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_SERVER)
		strcpy(conn->conn_sql, STMT_INSERT_SVRATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_QUE_ALL)
		strcpy(conn->conn_sql, STMT_INSERT_QUEATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_RESV)
		strcpy(conn->conn_sql, STMT_INSERT_RESVATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_NODE)
		strcpy(conn->conn_sql, STMT_INSERT_NODEATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_SCHED)
		strcpy(conn->conn_sql, STMT_INSERT_SCHEDATTR);

	LOAD_STR(conn, pattr->parent_id, 0);
	LOAD_STR(conn, pattr->attr_name, 1);
	LOAD_STR(conn, pattr->attr_resc, 2);
	LOAD_STR(conn, pattr->attr_value, 3);
	LOAD_INTEGER(conn, pattr->attr_flags, 4);

	if (pg_db_cmd(conn, conn->conn_sql, 5) != 0)
		return -1;

	return 0;
}

/**
 * @brief
 *	Update an attribute to the database
 *
 * @param[in]	conn - Database connection handle
 * @param[in]	info - The database object to be inserted
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 * @retval	 1 - Success but no rows updated
 *
 */
int
pg_db_update_attr(pbs_db_conn_t *conn, pbs_db_obj_info_t *info)
{
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;
	int resc_flag = 0;

	/* if attribute has a non-null, non-empty resource, set resc_flag */
	if (pattr->attr_resc != NULL && pattr->attr_resc[0] != 0)
		resc_flag=1;

	/*
	 * When updating attributes there could be two cases
	 * 1. The attribute does not have a resource
	 * 2. The attribute has a resource
	 *
	 * They are two different types of statements. Please see
	 * STMT_UPDATE_JOBATTR vs STMT_UPDATE_JOBATTR_RESC for a comparison.
	 * So, when the attribute has a resource, use the variant of the SQL
	 * statement that allows updating the resource, rather than the one
	 * that allows only updating the value
	 *
	 */
	if (pattr->parent_obj_type == PARENT_TYPE_JOB) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_UPDATE_JOBATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_UPDATE_JOBATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_SERVER) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_UPDATE_SVRATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_UPDATE_SVRATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_QUE_ALL) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_UPDATE_QUEATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_UPDATE_QUEATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_RESV) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_UPDATE_RESVATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_UPDATE_RESVATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_NODE) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_UPDATE_NODEATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_UPDATE_NODEATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_SCHED) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_UPDATE_SCHEDATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_UPDATE_SCHEDATTR);
	}

	LOAD_STR(conn, pattr->parent_id, 0);
	LOAD_STR(conn, pattr->attr_name, 1);
	LOAD_STR(conn, pattr->attr_resc, 2);
	LOAD_STR(conn, pattr->attr_value, 3);
	LOAD_INTEGER(conn, pattr->attr_flags, 4);
	return (pg_db_cmd(conn, conn->conn_sql, 5));
}

/**
 * @brief
 *	Delete an attribute to the database
 *
 * @param[in]	conn - Database connection handle
 * @param[in]	info - The database object to be deleted
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 * @retval	 1 - Success but no rows deleted
 *
 */
int
pg_db_delete_attr(pbs_db_conn_t *conn, pbs_db_obj_info_t *info)
{
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;
	int resc_flag = 0;

	/* if attribute has a non-null, non-empty resource, set resc_flag */
	if (pattr->attr_resc != NULL && pattr->attr_resc[0] != 0)
		resc_flag=1;

	/*
	 * When updating attributes there could be two cases
	 * 1. The attribute does not have a resource
	 * 2. The attribute has a resource
	 *
	 * They are two different types of statements. Please see
	 * STMT_DELETE_JOBATTR_RESC vs STMT_DELETE_JOBATTR for a comparison.
	 * So, when the attribute has a resource, use the variant of the SQL
	 * statement that allows updating the resource, rather than the one
	 * that allows only updating the value
	 *
	 */
	if (pattr->parent_obj_type == PARENT_TYPE_JOB) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_DELETE_JOBATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_DELETE_JOBATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_SERVER) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_DELETE_SVRATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_DELETE_SVRATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_QUE_ALL) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_DELETE_QUEATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_DELETE_QUEATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_RESV) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_DELETE_RESVATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_DELETE_RESVATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_NODE) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_DELETE_NODEATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_DELETE_NODEATTR);
	} else if (pattr->parent_obj_type == PARENT_TYPE_SCHED) {
		if (resc_flag == 1)
			strcpy(conn->conn_sql, STMT_DELETE_SCHEDATTR_RESC);
		else
			strcpy(conn->conn_sql, STMT_DELETE_SCHEDATTR);
	}

	LOAD_STR(conn, pattr->parent_id, 0);
	LOAD_STR(conn, pattr->attr_name, 1);
	if (resc_flag == 1) {
		LOAD_STR(conn, pattr->attr_resc, 2);
		return (pg_db_cmd(conn, conn->conn_sql, 3));
	}

	return (pg_db_cmd(conn, conn->conn_sql, 2));
}

/**
 * @brief
 *	Load an attribute from the database
 *
 * @param[in]	conn - Database connection handle
 * @param[in]	info - The database object to be loaded
 *
 * @return      Error code
 * @retval	-1 - Failure
 * @retval	 0 - Success
 * @retval	 1 -  Success but no rows loaded
 *
 */
int
pg_db_load_attr(pbs_db_conn_t *conn, pbs_db_obj_info_t *info)
{
	PGresult *res;
	int rc;
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;

	LOAD_STR(conn, pattr->parent_id, 0);
	LOAD_STR(conn, pattr->attr_name, 1);

	if ((rc = pg_db_query(conn, conn->conn_sql, 2, &res)) != 0)
		return rc;

	load_attr(res, pattr, 0);
	return 0;
}


/**
 * @brief
 *	Find a set of attribute in the database (for a job/node/resv etc)
 *
 * @param[in]	conn - Database connection handle
 * @param[out]	st   - opaque state parameter that retains the cursor state
 * @param[in]	info - The database object to be found
 * @param[in]	opts - Options if any to use for the find query
 *
 * @return      Error code
 * @retval	-1 - Error
 * @retval	 0 - Success and > 0 rows were returned
 * @retval	 1 - Execution succeeded but statement did not return any rows
 *
 */
int
pg_db_find_attr(pbs_db_conn_t *conn, void* st,
	pbs_db_obj_info_t *info,
	pbs_db_query_options_t *opts)
{
	PGresult *res;
	pg_query_state_t *state = (pg_query_state_t *) st;
	pbs_db_attr_info_t *pattr = info->pbs_db_un.pbs_db_attr;
	int rc;
	int numVars = 1;

	if (!state)
		return -1;

	if (pattr->parent_obj_type == PARENT_TYPE_JOB) {
		if (opts && opts->flags == PBS_DB_SINGLE_ATTR_FETCH)
			strcpy(conn->conn_sql, STMT_SELECT_JOBATTR_SPECIFIC);
		else
			strcpy(conn->conn_sql, STMT_SELECT_JOBATTR);
	}
	else if (pattr->parent_obj_type == PARENT_TYPE_SERVER)
		strcpy(conn->conn_sql, STMT_SELECT_SVRATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_QUE_ALL)
		strcpy(conn->conn_sql, STMT_SELECT_QUEATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_RESV)
		strcpy(conn->conn_sql, STMT_SELECT_RESVATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_NODE)
		strcpy(conn->conn_sql, STMT_SELECT_NODEATTR);
	else if (pattr->parent_obj_type == PARENT_TYPE_SCHED)
		strcpy(conn->conn_sql, STMT_SELECT_SCHEDATTR);

	LOAD_STR(conn, pattr->parent_id, 0);
	if(opts && opts->flags == PBS_DB_SINGLE_ATTR_FETCH)
	{
      numVars = 2;
	  LOAD_STR(conn, pattr->attr_name, 1);
	}

	if ((rc = pg_db_query(conn, conn->conn_sql, numVars, &res)) != 0)
		return rc;

	state->row = 0;
	state->res = res;
	state->count = PQntuples(res);
	return 0;
}

/**
 * @brief
 *	Get the next attribute from a resultset created in a previous find
 *
 * @param[in]	conn - Database connection handle
 * @param[out]	st - opaque state parameter that retains the cursor state
 * @param[out]	info - The database object to be found
 *
 * @return      Error code
 *		(Even though this returns only 0 now, keeping it as int
 *			to support future change to return a failure)
 * @retval	 0 - Success
 *
 */
int
pg_db_next_attr(pbs_db_conn_t *conn, void* st,
	pbs_db_obj_info_t *info)
{
	pg_query_state_t *state = (pg_query_state_t *) st;

	load_attr(state->res, info->pbs_db_un.pbs_db_attr, state->row);
	return 0;
}
